
#include <EigenIntegration/Overrides.hpp>
#include <Eigen/Dense>
#include <universal/number/posit/posit.hpp>

#include <Bembel/IO>


using Scalar_ = sw::universal::posit<64,3>;

class FakeDivergenceConformingOperator;
template <>
struct Bembel::LinearOperatorTraits<FakeDivergenceConformingOperator> {
  typedef Eigen::VectorX<Scalar_> EigenType;
  typedef Eigen::VectorX<Scalar_>::Scalar Scalar;
  enum { OperatorOrder = 0, Form = DifferentialForm::DivConforming };
};

int main() {
  using namespace Bembel;
  Geometry<Scalar_> geo("sphere.dat");

  // The refinement level for the visualization is independent of that of the
  // simulation since one might consider to visualize a coarse discretisation on
  // a smooth geometry.
  const int refinement_level = 4;

  // The VTKwriter sets up initial geomety information.
  VTKSurfaceExport<Scalar_> writer(geo, refinement_level);

  // Now we can add user defined data. There are different options. Since you
  // might consider to visualize a solution of a computation, we will set up a
  // "fake" ansatz-space and showcase that.
  AnsatzSpace<FakeDivergenceConformingOperator, Scalar_> aspace(geo, 2, 1, 1);
  Eigen::VectorX<Scalar_> coefficients(aspace.get_number_of_dofs());
  for (int j = 0; j < aspace.get_number_of_dofs(); ++j) {
    coefficients(j) = (j % 10) * 0.1;
  }
  FunctionEvaluator<FakeDivergenceConformingOperator, Scalar_> evaluator(aspace);
  evaluator.set_function(coefficients);

  // One can use either one of the following formats:
  // std::function<Scalar_(int, Eigen::Vector2<Scalar_>)>& fun)
  // std::function<Eigen::Vector3<Scalar_>(int, Eigen::Vector2<Scalar_>)>
  // std::function<Scalar_(Eigen::Vector3<Scalar_>)>
  // std::function<Eigen::Vector3<Scalar_>(Eigen::Vector3<Scalar_>)>
  std::function<Eigen::Vector3<Scalar_>(int, const Eigen::Vector2<Scalar_>&)> fun1 =
      [&](int patch_number, const Eigen::Vector2<Scalar_> &reference_domain_point) {
        return evaluator.evaluateOnPatch(patch_number, reference_domain_point);
      };

  std::function<Scalar_(const Eigen::Vector3<Scalar_>&)> fun2 =
      [](const Eigen::Vector3<Scalar_>& point_in_space) { return point_in_space(0); };

  // With the help of these functions, the data sets are generated by the
  // VTKWriter
  writer.addDataSet("Vector_Field", fun1);
  writer.addDataSet("X-Value", fun2);

  // Finally, we print to file.
  writer.writeToFile("example.vtp");
  return 0;
}
